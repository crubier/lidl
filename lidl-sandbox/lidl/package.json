{
  "name": "lidl",
  "version": "0.1.8",
  "description": "The LIDL Interaction Desccription Language",
  "main": "index.js",
  "scripts": {
    "test": "gulp jest",
    "prepublish": "gulp prepublish"
  },
  "keywords": [
    "iii",
    "lidl",
    "interaction",
    "interactive",
    "interactor",
    "ui",
    "dsl",
    "domain specific language"
  ],
  "author": {
    "name": "Vincent Lecrubier",
    "email": "vincent.lecrubier@gmail.com",
    "url": "http://www.vincentlecrubier.fr/"
  },
  "license": "MIT",
  "dependencies": {
    "escodegen": "^1.7.0",
    "json-stringify-safe": "^5.0.1",
    "lodash": "^3.10.1"
  },
  "devDependencies": {
    "async": "^1.4.2",
    "chalk": "^1.1.1",
    "circular-json": "^0.2.0",
    "esprima": "^2.6.0",
    "factis": "^1.0.3",
    "json-stringify-safe": "^5.0.1",
    "minimist": "^1.2.0",
    "del": "^2.0.2",
    "gulp": "^3.9.0",
    "gulp-istanbul": "^0.10.1",
    "gulp-jest": "^0.4.0",
    "gulp-mocha": "^2.1.3",
    "gulp-newer": "^0.5.1",
    "gulp-peg": "^0.1.2",
    "gulp-plumber": "^1.0.1",
    "gulp-sourcemaps": "^1.6.0",
    "gulp-uglify": "^1.4.2",
    "gulp-util": "^3.0.6",
    "istanbul": "^0.3.22",
    "jest-cli": "^0.5.10",
    "mocha": "^2.3.3",
    "pegjs": "^0.9.0",
    "vinyl-buffer": "^1.0.0",
    "vinyl-source-stream": "^1.1.0"
  },
  "jest": {
    "collectCoverage": true,
    "testPathIgnorePatterns": [
      "node_modules",
      "src"
    ]
  },
  "readme": "\n[![Travis](https://img.shields.io/travis/crubier/iii.svg?style=flat-square)]()\n[![Gemnasium](https://img.shields.io/gemnasium/crubier/iii.svg?style=flat-square)]()\n[![Code Climate](https://img.shields.io/codeclimate/github/crubier/iii.svg?style=flat-square)]()\n[![npm](https://img.shields.io/npm/v/iii.svg?style=flat-square)]()\n[![npm](https://img.shields.io/npm/dm/iii.svg?style=flat-square)]()\n\n\n\n# III.js\n\n\n\n\nA simple language to describe interactive systems.\n\nhttp://crubier.github.io/iii\n\nProgramming languages are nice for **computations**. However, describing interactions with programming languages is **painful**. We need a language for **interactions**. That is what III is for.\n\nForget about programming, just describe interactions and let III do the rest.\n\nThis document contains the following sections:\n\n- [Tutorial](#tutorial)\n- [Base Interactions semantics](#base-interactions-semantics)\n- [Advanced Interactions semantics](#advanced-interactions-semantics)\n- [Example](#example)\n\n## Tutorial\n\nThis tutorial will cover the basic features of the III Language:\n\n- [Focus on interactions](#focus-on-interactions)\n- [Simple syntax](#simple-syntax)\n- [Synchronous execution](#synchronous-execution)\n- [Interaction activation](#interaction-activation)  \n- [Emissions and Receptions](#emissions-and-receptions)\n- [Base data types](#base-data-types)\n- [Complex data types](#complex-data-types)\n\n### Focus on interactions\n\nA III system represent one *interaction*. An *interaction* can be composed of several simpler *interactions*. This means that any III system is a composition of *interactions*. In fact, in III, pretty much everything is an interaction. Conditionals, assignments, variables... Everything is represented as *interactions*.\n\n#### Rationale\n\nSince we want to describe interactive systems, the only entity that adds value to the description is the interaction. We are interested only in aspects relevant to the *interaction* of systems. The details of the *computations* are not relevant for our purpose, so they are defered to other languages.\n\n### Simple syntax\n\nThanks to the over-use of parentheses, the expression grammar of III is really simple:\n\nexpression  :=   '(' element* ')'\nelement     :=   expression | identifier\nidentifier  :=   anything without parentheses\n\nSaid simply, an expression is a sequence of identifiers and sub-expressions, enclosed in parentheses. Here is an example expression in III:\n\n( when (anEvent) do ( (this) and (that) ) )\n\nBut, you ask, how do we know which operator an expression refers to? Well, this is simple: the name of the operator of an expression is the concatenation of its identifiers, with sub-expressions replaced by `$`. `$` stands for *\"something\"*. For example the expression `((a)+(b))` uses the operator `$+$`, pronounced *\"something plus something\"*.\n\nTo make a parallel with a more classical way to represent expressions, the above expression would usually be represented as :\n\n```\nwhen$do$(anEvent,$and$(this,that))\n```\n\n#### Rationale\n\nWhy such an unusual syntax ?\n\nFirst, the resulting syntax is very general, and similar to natural language, just with a lot of additional parentheses. These parentheses are made invisible when editing the code in an appropriate IDE, which makes reading III as easy as reading natural language.\n\nThere is only one syntax for all: All these *prefix* operators like `!a`, *infix* operators like `a + b`, *postfix* operators like `i++`, *named* operators like `sin(x)` are represented the same way. This should hopefully make III easier to understand for beginnners.\n\nFinally, this syntax takes the current evolution of programming languages to its logical conclusion. For example, it generalizes the notion of *Named function parameters* as used in Apple's *Swift Programming Language*, and in Microsoft's *C#*. Javascript developpers also use *argument maps* instead of *positional arguments*. Here is a table comparing different programming languages:\n\n| Language      | Expression                                                              |\n|:--------------|:------------------------------------------------------------------------|\n| C, Java       | `CalculateBMI(83,185)`                                                  |\n| Javascript    | `CalculateBMI({weight:83,height:185})`                                  |\n| C#, Swift     | `CalculateBMI(weigth:83,height:185)`                                    |\n| III (Simple)  | `(BMI (83)kg (185)cm)`                                                  |\n| III (Verbose) | `(Body Mass Index of someone who weights (83) kg and is (185) cm high)` |\n\nNote how III's syntax allows expressions to be much clearer on their semantics. For example, expected units of parameters are only expressed in III.\n\n### Synchronous execution\n\nIII systems are synchronous. This means that interactions are evaluated at discrete points in time, all at once. For example, the expression:\n\n( when (anEvent) do ( (output) = (5) ) )\n\nWill be evaluated at discrete points in time, called steps. Every expression of this composed expression will be evaluated at every step. For instance, here is a simplified execution, which does **not** actually comply to the actual semantics of the language:\n\n| Step | anEvent | output |\n|:----:|:-------:|:------:|\n|  0   |  `no`   |  `~`   |\n|  1   |  `yes`  |  `5`   |\n|  2   |  `no`   |  `~`   |\n|  3   |  `yes`  |  `5`   |\n\n#### Rationale\n\nSynchronous execution avoids spaghetti behaviours. The state of the system is explicitly defined for each execution step. This makes reasoning about code much simpler.\n\nSynchronous execution also makes verification much easier.\n\n### Interaction activation\n\nBehind the scenes, data is represented as a couples _< activation, value >_, where:\n\n- _activation_ is a boolean.\n- _value_ has a type. We will explain values and types later.\n\nThis means that every expression, every sub-expression is  actually a couple _< activation, value > _. Even the assignment, `$=$`, is a couple _< activation, value>_.\n\nAn interaction's _activation_ represents the fact that the interaction exists and is active at a point in time, or not. For example, if an interaction represents an event, then it will only be activated when the event happens. As another example, the assignment interaction `$=$` is only effective when its _activation_ is _true_. If an interaction's _value_ is not defined anywhere, then its _activation_ is _false_.\n\nIf an interaction activation is false, we write its value as **~**. Here is a table showing a few examples:\n\n\n| Couple                           | Notation |\n|:---------------------------------|:---------|\n| $ \\langle \\top, 0 \\rangle$       | `0`      |\n| $ \\langle \\top, 1 \\rangle $      | `1`      |\n| $ \\langle \\top, \\top \\rangle $   | `true`   |\n| $ \\langle \\top, \"text\" \\rangle $ | `\"text\"` |\n| $ \\langle \\bot, 0 \\rangle $      | `~`      |\n| $ \\langle \\bot, 3 \\rangle $      | `~`      |\n| $ \\langle \\bot, \"text\" \\rangle $ | `~`      |\n| $ \\langle \\bot, \\top \\rangle $   | `~`      |\n\n\n#### Rationale\n\nIn previous approaches, and in some other languages, a difference is made between *events* and *flows*, which are considered as two different first-class entities.\n\nIn these approaches, *events* represent data defined at discrete points in time, while *flows* represent data defined on continuous time intervals. But when we think about it, the only difference between an *event* and a *flow* lies in the domain of the *time → value* function. For *events* this set is discrete. For *flows* this set is continuous.\n\nThe logical conclusion of this remark is that the merger of these two concepts needs to include the indicator function of the domain of the *time → value* function. This indicator function is the `activation`, while the *time → value* function is the `value`.\n\n### Emissions and Receptions\n\nInteractions can represent *reception* of data, they are then called `reception`. Receptions are really similar to functions in other programming languages. Like functions, they take data in, compute and *return* a value, without side effect. Receptions are the things which are on the right-hand side of assignments.\n\nInteractions can also represent *emission* of data, they are then called `emission`. Emissions are the opposite of receptions. As a consequence, experienced coders struggle to understand emissions at first. The data flow in emissions is the exact opposite of the data flow in receptions. Instead of *returning* a value, receptions are *given* a value; instead of being *given* arguments values, emissions *return* values for their arguments. Emissions are the things which are on the left-hand side of assignments.\n\nSome interactions represent both *reception* and *emission* are just called `interaction`. They can emit and receive data. Typically, only state variables are `interactions`. Inputs of the system are `receptions` and outputs are `emissions`. But `emissions` are not necessarily `outputs`, and `receptions` are not necessarily `inputs`. They can be internal.\n\nAs a first example, look at the following interaction:\n\n( when (anEvent) : ( (theOutput) = (5) ) )\n\nIn this interaction, `anEvent` is a `reception`, while `theOutput` is an `emission`. But that is not all ! Remember, everything is an interaction ! Here is the complete table of interactions of this example:\n\n|                 Interaction                  |   Type   |    Kind     |  Operator   |\n|:--------------------------------------------:|:--------:|:-----------:|:-----------:|\n|                 `(anEvent)`                  |  `void`  | `reception` |  `anEvent`  |\n|                    `(5)`                     | `number` | `reception` |     `5`     |\n|                `(theOutput)`                 | `number` | `emission`  | `theOutput` |\n|            `((theOutput) = (5))`             |  `void`  | `emission`  |    `$=$`    |\n| `( when (anEvent) : ( (theOutput) = (5) ) )` |  `void`  | `emission`  |  `when$:$`  |\n\n#### Rationale\n\nAgain, this language feature is taking evolutions of languages to its natural conclusion.\nHere is a table presenting the evolution of how different programming languages treat assignments:\n\n| Language |              Expression              |                                                       Remark                                                       |\n|:--------:|:------------------------------------:|:------------------------------------------------------------------------------------------------------------------:|\n| Assembly |      `cpy res, a; add res, b;`       |                                        Expressions cannot be nested at all                                         |\n| C, Java  |        `res = a + ( b * c );`        |       Arbitrary expressions on the right hand side of assignment, only variable names on the left hand side        |\n|  JS ES6  |       `{ x, y } = f(a,(b+c));`       | Arbitrary expressions on the right hand side of assignment, restricted subset of expressions on the left hand side |\n|   III    | `( ( (x) or (y) ) = ( (a) + (b) ) )` |                               Arbitrary expressions on both sides of the assignment                                |\n\nThis shows that the *emission* / *reception* paradigm is a generalisation of current evolutions of programming languages, such as the destructuring assignment.\n\n### Base data types\n\nThere are few different base types:\n\n| Type      | Description                                                | Example literals                 |\n|:----------|:-----------------------------------------------------------|:---------------------------------|\n| `void`    | Bottom type, carries no data except activation information | `active`, `~`                    |\n| `boolean` | When active it can be either true or false                 | `true`,`false`, `~`              |\n| `number`  | Can be an integer or a float                               | `0`,`1.`,`13.37`,`-42`, `~`      |\n| `text`    | Any sequence of unicode characters                         | `\"foo\"`, `\"this is a text\"`, `~` |\n\n#### Rationale\n\nDo we need more ? The user can always define custom enumerated types, so we should be ok like that. Booleans are not even necessary.\n\n### Complex data types\n\nThere are different constructions for complex types:\n\n| Type                               | Description                                                                     | Example type                                   |\n|:-----------------------------------|:--------------------------------------------------------------------------------|:-----------------------------------------------|\n| `[ <type1>, <type2> ]`             | Tuples are combinations of a fixed number of different types in a certain order | `[boolean,number,number]`, `[number,text]`     |\n| `{ name1:<type1>, name2:<type2> }` | Objects are tuples whose elements are identified by name instead of position    | `{x:number,y:number}`,`{id:text,value:number}` |\n\nThe following complex data types may one day be implemented in III:\n\n| Type                           | Description                                                                                     | Example type                                               |\n|:-------------------------------|:------------------------------------------------------------------------------------------------|:-----------------------------------------------------------|\n| `[ <type1>... ]`               | **(Not implemented)** Arrays are combinations of variable number of identical types             | `[number...]`,`[text...]`                                  |\n| `{ <typekey>:<typevalue>... }` | **(Not implemented)** Maps are arrays whose elements are identified by name instead of position | `{text:number...}`,`{number:text...}`                      |\n| `[ <type1> or <type2> ]`       | **(Not implemented)** Unions are tuples with only one value active at a time                    | `[ text or number ]`, `[ {x:number, y:number} or number ]` |\n| `[  <type1> → <type2> ]`       | **(Not implemented)** Pure functions with domain type1, codomain type2, and no side effects     | `[number → text]`, `[void → number]`                       |\n\n#### Tuples\n\nFor each Tuple type, a set of emissions and receptions are defined. For example, the type:\n\ndata myType : [ <type1>, <type2> ]\n\nWill generate the following emissions and receptions, lazily at compile-time:\n\n- Decomposing receptions (example use: `x = a[1]`)\n- `<type1> reception ( (myType reception x) [1] )`\n- `<type2> reception ( (myType reception y) [2] )`\n- Decomposing emissions (example use: `a[1] = x`)\n- `<type1> emission ( (myType emission x) [1] )`\n- `<type2> emission ( (myType emission y) [2] )`\n- Composing receptions : (example use: `a = [x,y]`)\n- `myType reception ( [ (<type1> reception x) , (<type2> reception y) ] )`\n- Composing emissions : (example use: `[x,y] = a`)\n- `myType emission ( [ (<type1> emission x) , (<type2> emission y) ] )`\n\nThese definitions allow to write such things:\n\n[ a, [b, c] ] = [ 3, [4, 5] ]\n\nWhich is equivalent to:\n\na = 3; b = 4; c = 5;\n\n#### Objects\n\nSimilarly, objects are interactions, so they can be received and emitted\n\n{ weight:a, height:b } = { weight:83, height:184 }\n\nis equivalent to:\n\na = 83; b = 184;\n\nAny composition of complex types is an interaction, so this is possible:\n\n[{name:nameOfTheHeaviest,weight:maxWeight},...] = ( sort by weight ([{name:\"toto\",weight:50},{name:\"titi\",weight:75}]) )\n\nis equivalent to:\n\nnameOfTheHeaviest=\"titi\"; maxWeight=75;\n\n#### Rationale\n\nInteraction involve exchange of complex data. Complex data should be part of the language.\n\nIn combination with other languages features, complex data types enable very expressive code.\n\n\n### Data type vs Interface\n\nTypes :\n\n- bottom type : `activation` = `{}` = `()` = `[]`\n  - enumeration : `enum(literal1,literal2,literal3)`\n  - boolean : `boolean`\n  - number : `number`\n  - text : `text`\n  - tuples : `(<type1>,<type2>)`\n  - structures : `{field1:<type1>,field2:<type2>}`\n  - arrays : `[<type1>]`\n  - unions : `|<type1>,<type2>|`\n  - top type : `any` = `|<firsttype>,<secondtype>,...,<lasttype>|`\n\n\n  The classical notion of data type encompass two different notions :\n\n  - Data type of a function declaration (e.g. `float sin(float x);`) : We call it **interface** because it is the specification of the type of data that *can* be received or sent by an interaction. It does not specify the type of any actual data, but it merely gives the shape of the channel the data flows through. Channel types are not specified in most weakly typed languages. They are specified explicitely in III.\n  - Data type of a variable instantiation (e.g. `int x = 2;`) : We call it **data type** because it is the specification of the type of the actual data. Data types are often specified as `var` in weakly typed languages, and redundantly declared in strongly typed language. They are specified implicitely and infered automatically in III.\n\n  In III, data types are specified implicitely, through instantiation, while channel types are specified explicitely.\n\n  A data type is a simple type expression.\n\n  A channel type is a type expression, with additional information about the flow direction using `in` and `out` keywordds. Channel type is a type expression tree where the only path going from the root to any leaf crosses one and only one \"in\" or \"out\".\n\n\n  #### Rationale\n\n  Basically, don't fix the direction of dataflow ! Restrict it to AST edges to enable compositional verification, but allow it to go in both direction at the same time instead of only down (classical languages) or only up or down (iii with simple types)\n\n  ----------------------------------------------------------------------------------------\n\n  ## Base Interactions semantics\n\n  ### Assignment\n\n  #### Signature\n\n  void emission ( (<type1> emission a) = (<type1> reception b) )\n\n  #### Example of use\n\n  ( (a) = (b) )\n\n  #### Semantics\n\n  When the assignment (`(a)=(b)`) is active, the emission (`a`) on the left is given the value returned by the reception (`b`) on the right.\n\n  #### Truth table\n\n| `((a)=(b))` |    `(b)`    |  `(a)`  |\n|:-----------:|:-----------:|:-------:|\n| **active**  | **_value_** | _value_ |\n| **active**  |    **~**    |    ~    |\n|    **~**    | **_value_** |    ~    |\n|    **~**    |    **~**    |    ~    |\n\n  #### Example chronogram\n\n  | Step | `((a)=(b))` | `(b)` | `(a)`|\n  |:-:|:----------:|:-----:|:-:|\n| 0 |   **~**    | **4** | ~ |\n| 1 |   **~**    | **5** | ~ |\n| 2 | **active** | **6** | 6 |\n| 3 | **active** | **7** | 7 |\n| 4 | **active** | **~** | ~ |\n| 5 |   **~**    | **9** | ~ |\n\n  ### All\n\n  #### Signature\n\n  <type1> emission ( all (<type1> emission a) (<type1> emission b) )\n\n  #### Example of use\n\n  ( all (a) (b) )\n\n  #### Semantics\n\n  The value given to `(all(a)(b))` is given to both `(a)` and `(b)`\n\n  #### Truth table\n\n  | `(all(a)(b))` | `(b)` | `(a)` |\n  |:-----------:|:-------:|:-------:|\n| **_value_** | _value_ | _value_ |\n|    **~**    |    ~    |    ~    |\n\n  #### Example chronogram\n\n  | Step | `(all(a)(b))` | `(a)` | `(b)`|\n  |:-:|:-----:|:-:|:-:|\n| 0 | **~** | ~ | ~ |\n| 1 | **~** | ~ | ~ |\n| 2 | **6** | 6 | 6 |\n| 3 | **7** | 7 | 7 |\n| 4 | **~** | ~ | ~ |\n| 5 | **8** | 8 | 8 |\n\n  ### Either\n\n  #### Signature\n\n  <type1> emission ( either (<type1> emission a) (<type1> emission b) )\n\n  #### Example of use\n\n  ( either (a) (b) )\n\n  #### Semantics\n\n  The value given to `(either(a)(b))` is given to either `(a)` or `(b)`\n\n  #### Truth table\n\n  Non deterministically choosen between the two following tables:\n\n  | `(either(a)(b))` | `(b)` | `(a)` |\n  |:-----------:|:-------:|:-:|\n| **_value_** | _value_ | ~ |\n|    **~**    |    ~    | ~ |\n\n\n  | `(either(a)(b))` | `(b)` | `(a)` |\n  |:-----------:|:-:|:-------:|\n| **_value_** | ~ | _value_ |\n|    **~**    | ~ |    ~    |\n\n  #### Example chronogram\n\n  | Step | `(either(a)(b))` | `(a)` | `(b)`|\n  |:-:|:-----:|:-:|:-:|\n| 0 | **~** | ~ | ~ |\n| 1 | **5** | 5 | ~ |\n| 2 | **6** | ~ | 6 |\n| 3 | **7** | ~ | 7 |\n| 4 | **~** | ~ | ~ |\n| 5 | **8** | 8 | ~ |\n\n  ### When\n\n  #### Signature\n\n  void emission ( when (void reception a) : (void emission b) )\n\n  #### Example of use\n\n  ( when (a) : (b) )\n\n  #### Semantics\n\n  When `(when(a):(b))` is active and `(a)` returns the active value then `(b)` is given the active value. Note how this is similar to the assignment `((b)=(a))` with `void` values.\n\n  #### Truth table\n\n  | `(when(a):(b))` | `(a)` | `(b)` |\n  |:----------:|:----------:|:------:|\n| **active** | **active** | active |\n| **active** |   **~**    |   ~    |\n|   **~**    | **active** |   ~    |\n|   **~**    |   **~**    |   ~    |\n\n  #### Example chronogram\n\n  | Step | `(when(a):(b))` | `(a)` | `(b)` |\n  |:-:|:----------:|:----------:|:------:|\n| 0 |   **~**    | **active** |   ~    |\n| 1 |   **~**    | **active** |   ~    |\n| 2 | **active** | **active** | active |\n| 3 | **active** | **active** | active |\n| 4 | **active** |   **~**    |   ~    |\n| 5 |   **~**    | **active** |   ~    |\n\n  ### Always\n\n  #### Signature\n\n  void emission ( always : (void emission b) )\n\n  #### Example of use\n\n  ( always : (a) )\n\n  #### Semantics\n\n  `(always:(a))` forces `(a)` to be active, even when `(always:(a))` is given the inactive value `~`.\n\n  #### Truth table\n\n  | `(always:(a))` | `(a)` |\n  |:----------:|:------:|::|\n| **active** | active |  |\n|   **~**    | active |  |\n\n  #### Example chronogram\n\n  | Step | `(always(a))` | `(a)` |\n  |:-:|:----------:|:------:|\n| 0 |   **~**    | active |\n| 1 |   **~**    | active |\n| 2 | **active** | active |\n| 3 | **active** | active |\n\n  ### Active\n\n  #### Signature\n\n  boolean reception ( active ( <type1> reception a ) )\n\n  #### Example of use\n\n  ( active (a) )\n\n  #### Semantics\n\n  When `(a)` is active, `(active(a))` returns `true`, and when `(a)` is not active, `(active(a))` returns `false`. `(active(a))` itself is always active, even when `(a)` is not.\n\n  #### Truth table\n\n  | `(a)` |`(active(a))` |\n  |:-----------:|:-----:|\n| **_value_** | true  |\n|    **~**    | false |\n\n  #### Example chronogram\n\n  | Step | `(a)` | `(active(a))` |\n  |:-:|:-----:|:-----:|\n| 0 | **~** | false |\n| 1 | **3** | true  |\n| 2 | **4** | true  |\n| 3 | **~** | false |\n| 4 | **5** | true  |\n| 5 | **~** | false |\n\n  ### Previous\n\n  #### Signature\n\n  <type1> reception ( previous ( <type1> reception a ) )\n\n  #### Example of use\n\n  ( previous (a) )\n\n  #### Semantics\n\n  Go back in time by one step. `(previous(a))` returns what  `(a)` returned on the previous execution step.\n\n  #### Example chronogram\n\n  | Step | `(a)` | `(previous(a))` |\n  |:-:|:-----:|:-:|\n| 0 | **~** | ~ |\n| 1 | **5** | ~ |\n| 2 | **6** | 5 |\n| 3 | **~** | 6 |\n| 4 | **8** | ~ |\n| 5 | **~** | 8 |\n\n  ### Init\n\n  #### Signature\n\n  void reception ( init )\n\n  #### Example of use\n\n  ( init )\n\n  #### Semantics\n\n  Active only on the first step, inactive the rest of the time.\n\n  #### Example chronogram\n\n  | Step | `(init)` |\n  |:-:|:------:|\n| 0 | active |\n| 1 |   ~    |\n| 2 |   ~    |\n| 3 |   ~    |\n| 4 |   ~    |\n| 5 |   ~    |\n\n  ### Default\n\n  #### Signature\n\n  <type1> reception ( ( <type1> reception a ) default ( <type1> reception b ) )\n\n  #### Example of use\n\n  ( (a) default (b) )\n\n  #### Semantics\n\n  If `(a)` is active, `((a)default(b))` returns `(a)`, else it returns `(b)`.\n\n  #### Truth table\n\n  | `(a)` | `(b)` | `((a)default(b))` |\n  |:-------------:|:-------------:|:---------:|\n| **_value a_** | **_value b_** | _value a_ |\n| **_value a_** |     **~**     | _value a_ |\n|     **~**     | **_value b_** | _value b_ |\n|     **~**     |     **~**     |     ~     |\n\n  #### Example chronogram\n\n  | Step |  `(a)` | `(b)` | `((a)default(b))` |\n  |:-:|:-----:|:-----:|:-:|\n| 0 | **~** | **0** | 0 |\n| 1 | **~** | **~** | ~ |\n| 2 | **3** | **~** | 3 |\n| 3 | **4** | **5** | 4 |\n| 5 | **~** | **2** | 2 |\n\n  ### Flow\n\n  #### Signature\n\n  void emission ( flow ( <type1> interaction a ) change ( <type1> reception b ) )\n\n  #### Example of use\n\n  ( flow (a) change (b) )\n\n  #### Semantics\n\n  Flow `(a)` from time step to time step, but give it value `(b)` when `(b)` is active.\n\n  #### Equivalent to\n\n  (  (a) = ( (b) default (previous(a)) ) )\n\n  #### Example chronogram\n\n  | Step | `(flow(a)change(b))` | `(b)` | `(a)`|\n  |:-:|:----------:|:-----:|:-:|\n| 0 |   **~**    | **~** | ~ |\n| 1 | **active** | **5** | 5 |\n| 2 | **active** | **~** | 5 |\n| 3 | **active** | **~** | 5 |\n| 4 | **active** | **3** | 3 |\n| 5 | **active** | **~** | 3 |\n| 6 | **active** | **~** | 3 |\n| 7 |   **~**    | **~** | ~ |\n\n  ## Advanced Interactions semantics\n\n  ### Apply\n\n  Signature\n\n  <type1> reception ( apply ( [<type2> →  <type1>] reception func ) on ( <type2> reception data ) )\n\n  Example of use\n\n  ( apply (func) on (a) )\n\n  Semantic\n\n  Returns the result of the application of a function `(func)` to data `(a)`\n\n  Associated chronogram\n\n  | Step | `(func)` | `(data)`| `(apply(func)on(a))` |\n  |:-:|:-------:|:-----:|:------:|\n| 0 |  **~**  | **0** |   ~    |\n| 1 | **sin** | **0** |   0.   |\n| 2 | **sin** | **2** | 0.909  |\n| 3 | **sin** | **~** |   ~    |\n| 4 |  **~**  | **3** |   ~    |\n| 5 | **cos** | **4** | -0.653 |\n| 6 | **cos** | **5** | 0.283  |\n| 7 |  **~**  | **6** |   ~    |\n\n\n\n\n\n\n  ----------------------------------------------------------------------------------------\n\n\n\n\n  ## Example\n\n\n  The speed controller application :\n\n  (speedcontroller (alarm:boolean out) (displayedspeed:number out) (targetspeed: number out) (actualspeed:number in) (increment: activation in) (decrement: activation out) ):\n  activation in :\n  (all\n    ((displayedspeed) = (actualspeed)),\n    ((alarm)=((actualspeed)>(targetspeed))),\n    ((targetspeed)=(incdec behavior(increment)(decrement)(actualspeed)(5)(30)(150)))\n    )\n    )\n\n\n\n    Increment Decrement behaviour :\n\n    (incdec behavior (inc: activation in) (dec:activation in) (actual:number in) (step:number in) (min:number in) (max:number in) ):\n    number out:\n    (restrict\n      (\n        (previous(this))\n        + (step) * (1 if (inc) is active)\n        - (step) * (1 if (dec) is active)\n        )\n        to range (min) (max)\n        )\n\n\n        Just a small utility function :\n\n        (1 if (theSignal:<type> in) is active):\n        number out :\n        (if (active(a)) then (1) else (0))\n\n\n        Ensure a value is in a range  :\n\n        (restrict (value:number in) to range (min:number in) (max:number in)):\n        number out:\n        ( if ((value)>(max))\n        then (max)\n        else ( if ((value)<(min))\n        then (min)\n        else (value)\n        )\n        )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        <!--\n\n\n\n\n\n        ## Examples\n\n        This piece of III code will be the running example of this document. It is an implementation of the TodoMVC example used to benchmark UI frameworks at [todomvc.com](todomvc.com).\n\n        Prerequisites:\n\n        html data: htmlelement\n\n        htmlelement data:\n        {name:text,attributes:[htmlattribute],content:[htmlelement]}\n\n        htmlattribute data:\n        {name:text,value:text}\n\n        htmlevent data:\n        {source:text,event:text,value:text}\n\n        htmlelement reception (<(text reception name)([htmlattribute] reception attr)>()</>)\n\n        html reception (buttonDown) : \"image of a button down\"\n        html reception (buttonUp) : \"image of a button up\"\n\n        void emission (toggle button (html emission scene) (boolean data model) (void reception click)) :\n        (\n        (when(click):((model)=(not(previous(model)))));\n        (always:((scene)=(if(model)then(buttonDown)else(buttonUp))))\n        )\n\n        void emission (simple button (html emission scene) (void reception click)) :\n        (\n        (when(click):((scene)=(buttonDown)))\n        (when(no(click))):((scene)=(buttonUp)))\n        )\n\n        Code:\n\n        mode data:\n        enum(all,active,completed)\n\n        todo data:\n        {name:text,completed:boolean}\n\n        void emission (todoItem\n        (todo data model)\n        (html emission scene)\n        (void reception changeCompletion)\n        (text reception changeName)\n        (void reception remove)\n        ) :\n\n        (\n        (simple button (removeButton) (clickRemoveButton))\n        (toggle button (completedButton) (model.completed))\n\n        (scene=(<(div) ()> () </>));\n        (when(changeCompletion):(negate ((theModel).completed)))\n        (when(remove):(negate ((theModel).completed)))\n\n        )\n\n        html reception (todoApp\n        ([todo...] interaction model)\n        ):\n\n\n\n        void emission (main (html emission scene) (event reception event)) :\n\n\n        (\n        ((scene) = (todoApp));\n        )\n\n\n\n\n        Ok test :\n\n\n        // Signature are :<argument type>:<this type>:<local type>:\n        // Syntax interactionName:<argument type>:<this type>:<local type>:behavior\n\n\n        //WIMP component : signature is :<argtype>:{scene:out scene,event:in event}:<localtype>:\n\n        incrementDecrement:\n        {step:in number,range:in range}: // argument\n        {scene:out scene, event:in event, value:out number}: //this\n        {inc: event, incbutton:buton,decbutton:button }: //local\n        all [\n        flow  {variable:this.value,\n        switch: this.value + step * 1IfActive this.event.increment - step * 1IfActive this.event.increment)\n        },\n        affect (this.scene,\n        {name:div,content[incbutton.scene,incbutton.scene]}\n        )\n        ];\n\n\n\n\n        button:\n        {}:\n        {scene:out scene, event:in event,clicked:out void}:\n        {}:\n        all [\n        this.scene = [rectangle(...),text(...)];\n        this.clicked = if {condition:this.event.type==\"click\",then:active,else:inactive};\n        ]\n\n\n\n        // Util\n\n        1IfActive:\n        in <type1>:\n\n        out number:\n        {}:\n        when {active:argument,then:affect(this,1),else:affect(this,0)}\n\n\n\n        //Behaviors : signature is  :<argtype>:in activation:<localtype>:\n\n        flow:\n        {variable:out <type>,switch:in <type>}:\n        in activation:\n        {}:\n        when {active:this,\n        then:when{ active:switch,\n        then:affect(argument.flow,argument.switch),\n        else:affect(argument.flow,previous argument.flow)\n        },\n        else:affect(argument.flow,inactive)\n      };\n\n\n      all:\n      [out activation]: //argument\n      in activation: //this\n      {}: //local\n      native\n\n      when:\n      {active:in activation, then:out activation:toVoid,dont:out activation:toVoid}:\n      in activation:\n      void:\n      native\n\n      toVoid:void:in activation:void:;\n\n\n\n\n      incrementDecrement (\n      button(\"increment\"),\n      button(\"decrement\")\n      )\n\n\n\n\n\n\n      todoListWimp:\n      [in todo]:\n      {scene:out scene,event:in event}:\n      {}:\n\n      local.content=map(argument,);\n\n\n\n      in activation (todoWIMP (in todo)):\n      {buttonCompleted: toggleButton,nameLabel: label,buttonDelete: button}:\n      {}:\n\n      {}\n\n      this.scene=div({},[\n      local.buttonCompleted.scene,\n      local.nameLabel.scene,\n      local.buttonDelete.scene\n      ])\n\n\n\n\n\n      TodoMVC\n\n      todo Data :\n      {key:uuid,name:text,completed:boolean}\n\n      event Data :\n      |\n      addTodo {name:text},\n      updateTodo {key:text,name:text}\n      completeTodo {key:uuid},\n      completeAll,\n      removeTodo {key:uuid}\n      removeComplete {}\n      |\n\n\n      (todoApp) :\n\n\n      {html:html out, action:action out, even:event in, todoList:todoList in} (todoListDisplay) :\n      [todoDisplay] : (map (argument.todoList)          )\n      {html : }\n\n\n      (todoDisplay) :\n      {html:html out, action:action out, even:event in, todo:todo in} : -->\n\n\n      ## Project setup\n\n      install with `npm install`\n\n      make with `gulp`\n\n      Locations:\n      - sources in `src/`\n      - tests using mocha in `test/`\n      - precompiled external libraries in `lib`\n      - compiled artifacts in `bin`\n      - browserified stuff in `dist`\n",
  "readmeFilename": "README.md",
  "gitHead": "7b16340099508d0667dff4399eaf18ce8a2e5bef",
  "_id": "lidl@0.1.8",
  "_shasum": "74f4d1523d68b885caafe251004789a2c0274778",
  "_from": "lidl@*"
}
