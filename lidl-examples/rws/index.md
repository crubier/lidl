# RWS IHM specification using LIDL# Textual specification## Color codeThis specification has been annotated using color codes in order to classify sentences in different concepts that can or cannot be expressed using LIDL.  - <span style='color:FireBrick'>Data types</span>  - <span style='color:DarkTurquoise'>Interfaces</span>  - <span style='color:Green'>Interactions</span>  - <span style='color:MediumVioletRed'>Architecture</span>  - <span style='color:Goldenrod'>Timing/External/Ergonomy</span>## Definitions  #. <span style='color:MediumVioletRed'>The RWS is the system in charge of the computation and presentation of alerts. It is composed of two mains part: a RWS core in charge of computing the state of all alerts, and a RWS HMI in charge of the presentation of the alerts to the supervisor.</span>  #. <span style='color:MediumVioletRed'>The supervision operator is referred to as supervisor in the specification.</span>  #. <span style='color:FireBrick'>The terms **“event occurrence”** refers to something that takes place at a certain place in space and time. The term **“event”** refers to the set of all event occurrences that share certain common characteristics, in the same way as a class describes all the individual objects that share the same structure. An event is a class of event occurrences. "Activation of alert A" is an event.  The actual activations of alert A at times t_1, t_2, t_n are occurrences of the event "Activation of alert A".</span>  #. <span style='color:FireBrick'>An alert refers to some specific condition on the monitored system. For instance, “left wheel is blocked” is an alert. Satisfaction (or “activation”) of the condition “left wheel is blocked” is an event. The actual blocking of the wheel at time t is an occurrence of the event “left wheel is blocked”.</span>  #. <span style='color:FireBrick'>An alert signal is the means by which the supervisor is informed of the occurrence of the alert activation.</span><span style='color:DarkTurquoise'> The transmission of the alert signal to the supervisor is also called “presentation”.</span><span style='color:Green'>  It shall be noted that if the occurrence of the alert signal is conditioned by the satisfaction of some alert condition, the signal may continue to exist while the condition is negated.  It shall also be noted that the signal may cease to be transmitted to the supervisor for some time or be transmitted to the supervisor on demand (see specification).</span>  #. <span style='color:MediumVioletRed'>Activation conditions are evaluated from data produced by the rovers, the supervision station, the in-door stations, and the activation state of other alerts.</span>  #. <span style='color:FireBrick'>The monitored system is composed of: (i) a set of rovers, (ii) a supervision station, (iii) a set of in-door GPS stations (3 stations). It also covers all required communication means between these elements.</span>  #. <span style='color:FireBrick'>The global system is composed of the monitored system and the supervisor.</span>  #. <span style='color:FireBrick'>Alerts are categorized as "caution", "warning" or "advisory".</span>## Specification  1. **Signalling of alerts** <span style='color:Green'>The RWS IHM shall signal alerts occurrences to the supervision operator.</span> <span style='color:DarkTurquoise'>The reception of an alert signal shall provide the supervisor with sufficient information about the situation (e.g., which alert, at what time,…) </span><span style='color:Goldenrod'>during sufficient time. We consider that situation awareness is possible if the information is presented continuously to the supervisor for at least 3 seconds.</span>  #. **Separation between alerts signals** <span style='color:Green'>The signalling of an alert occurrence shall not alter / jeopardize the signalling of another alert occurrence.</span> *Rationale: Let the occurrence of alert A be presented to the supervisor when occurrence of alert B occurs. Then the message related to B shall not cover the message related to A up to the point where it makes message related to A unintelligible. Separation between messages related to alert A and alert B may be ensure in space and/or time.*  #. **Navigation through alert signals** <span style='color:Green'>If all alert signals cannot be transmitted at once to the supervisor, s/he shall be able to “navigate” through the set of alert signals in order for the transmission to be done sequentially.</span>  #. **The RWS is hosted on the supervision station.** <span style='color:MediumVioletRed'>The rovers communicate directly with the supervision station. The in-door GPS stations communicate indirectly with the supervision station through the rovers.</span>  #. **Uniqueness of alert signals** <span style='color:FireBrick'>There shall be a unique signal for a given alert.</span> <span style='color:Green'>If the signal for alert A is active (presented or not to the supervisor), then no other occurrence of alert A can be signalled to the supervisor.</span>  #. **Presentation latency** <span style='color:Green'>An alert signal shall be transmitted to the supervisor within at most 100ms after the triggering of the activation condition.</span>  #. **Presentation duration** <span style='color:Green'>An alert signal shall be transmissible (not necessarily transmitted) to the supervisor until it is cleared.</span>  #. **Acknowledgment** <span style='color:DarkTurquoise'>The RWS IHM shall provide the supervisor with a means to confirm that s/he has actually received the alert signal. This is referred to as « acknowledgement ».</span>  #. **Automatic acknowledgment** <span style='color:Green'>An alert may be acknowledged automatically when the alert activation condition is negated.</span>  #. **Concurrence between automatic and manual acknowledgment** <span style='color:Green'>An alert shall always be acknowledgeable by the supervisor even if automatic acknowledgment is configured.</span>  #. **Acknowledgment configuration** <span style='color:FireBrick'>The choice between automatic or supervisor-initiated  acknowledgement shall be alert-specific and be defined by configuration.</span>  #. **Acknowledgment state transmission** <span style='color:FireBrick'>The alert signal shall transmit the acknowledgement state of the alert.</span>  #. **Indication of non-transmitted alert signals** <span style='color:Green'>If the RWS IHM cannot transmit the alert signal to the supervisor (for instance due to lack of space), it shall at least transmit</span><span style='color:DarkTurquoise'> a signal indicating that there is a non-transmissible alert signal.</span>  #. **Provision of means to transmit alert signals** <span style='color:Green'>If the RWS IHM cannot transmit the alert signal to the supervisor (for instance due to lack of space), it shall provide</span><span style='color:DarkTurquoise'> some means</span> <span style='color:Green'>to activate the transmission of those alert signals.</span> <span style='color:DarkTurquoise'>Hints shall be provided to the supervisor</span><span style='color:Green'> to facilitate this operation.</span>  #. **Number of non-transmitted alert signals** <span style='color:Green'>If all active alerts cannot be presented simultaneously,</span> <span style='color:DarkTurquoise'>an indicator shall be provided to the supervisor</span> <span style='color:Green'>to let him know the total number of non-transmitted alert signals.</span>  #. **Manual clearing of alert signals** <span style='color:DarkTurquoise'>The RWS HMI shall provide a means for the supervisor</span> <span style='color:Green'>to clear an alert signal.</span>  #. **Clearing alert signals** <span style='color:Green'>Once cleared, an alert signal shall cease to be transmitted to the supervisor. Note that a new occurrence of the same alert signal may be transmitted later to the supervisor if the associated alert condition becomes asserted again.</span>  #. **Relation between acknowledging and clearing alert signals** <span style='color:Green'>An alert may only be cleared after being acknowledged.</span>  #. **Automatic clearing of alert signals** <span style='color:Green'>An acknowledged alert signal may be cleared automatically when its activation condition is negated.</span>  #. **Clearing configuration** <span style='color:FireBrick'>The choice between automatic or supervisor-initiated  clearing shall be alert-specific and be defined by configuration. </span>  #. **Priorities of alert signals** <span style='color:Green'>Alert signals shall be transmitted to the supervisor in such a way that alerts with high priorities are received by the supervisor preferably before alerts with lower priorities. Priority is defined according to the following precedence relations (level n+1 is used to sort alerts when attributes at levels n are equal):</span>    1. <span style='color:Green'>"warning" > "caution" > "advisory"</span>    #. <span style='color:Green'>priority within the category</span>    #. <span style='color:Green'>"not acked" > "acked"</span>    #. <span style='color:Green'>increasing time stamp. Timestamps are unique and monotonically</span> increasing.  #. **Attention getter** <span style='color:Goldenrod'>The attention of the supervisor shall be captured when an alert signal occurs.</span>  #. **Procedures** <span style='color:Green'>The supervisor shall be able to activate the</span><span style='color:DarkTurquoise'> presentation of the procedure</span> <span style='color:FireBrick'>associated with any signalled alert. Any alert may have an associated procedure. This is defined by configuration.</span>  #. **Relation between procedures and alert signals** <span style='color:Goldenrod'>The presentation of the alert / procedure shall clearly establish the relation between the alert signal and the procedure.</span>  #. **Procedure contents** <span style='color:FireBrick'>A procedure describes a sequence of actions to be performed by the supervisor. Each actions is called a “step”. Each step is associated with a message to be presented to the supervisor. The message describes an action to be carried out by the supervisor to diagnose, correct, etc. the associated alert.</span> <span style='color:Green'>At a given step in the procedure,</span> <span style='color:DarkTurquoise'>the last 2 steps (if possible) and the next 2 steps (if possible) shall be presented to the user</span> <span style='color:Goldenrod'>so that s/he can build a mental representation of what he is doing and anticipate the next actions.</span>  #. **Presentation of the current step** <span style='color:DarkTurquoise'>The current step shall be clearly indicated on the presented procedure.</span>  #. **Cancelling a procedure** <span style='color:DarkTurquoise'>The supervisor shall be able to cancel a procedure.</span><span style='color:Green'> Cancelling a procedure means « ceasing » to present the procedure.  The procedure may be presented again. In that case, it shall start again at the first step of the procedure.</span>  #. **Presentation of the procedure state** <span style='color:FireBrick'>The state of the procedure (“not yet started”, “completed”, or “at step <X>”) shall be transmitted by the alert signal.</span>  #. **Stacking of procedures** <span style='color:Green'>It shall be able to present procedure for alert B while procedure for alert A is being presented. The supervisor shall be able to come back to procedure A and continue the procedure from the step where it was interrupted.</span>  #. **Initial step of the procedures** <span style='color:Green'>All procedures are set in their initial state at system startup.</span>  #. **Effect of alert signal clearing on procedures** <span style='color:Green'>When an alert is manually cleared, the procedure shall be abandoned (even if it was interrupted by the opening of another alert). Note: the procedure shall not be abandoned if the alert is automatically cleared.</span>  #. **Effect of alert signal clearing on procedure stacking** <span style='color:Green'> When a procedure is cancelled, any active procedure that was interrupted by the one that is cancelled shall be presented again (in FIFO order).</span>    #. **Procedure actions** <span style='color:Green'>The next step of a procedure may be determined</span><span style='color:DarkTurquoise'> by a supervisor action.</span> <span style='color:FireBrick'>Actions are “YES/NO/ DONE”.</span># LIDL specification## Data typesIn this section we describe the <span style='color:FireBrick'>Data types</span> expressed in the specification. We mainly use the `data` keyword of LIDL.We use the *new* Algebraic data types notation of LIDL here, because it is much more expressive and convenient than the previous record-only data types.Note that we also define several interactions which are associated with the data types. These data types and their associated interactions represent the abstract data types we are interested in.### Pre existing data typesLIDL has several built-in types. Here are their "definition" using the algebraic data type syntax:    data Boolean is (true)|(false)    data Number is (1)|(2)|(3)| ... |(-1)|... |(-0.1)|...    data Text is ("a")|("b")| ... | ("aa") | ("ab") | ...    data Date is Number### SystemsHere we define the systems expressed in the [specification](#textual-specification), using data types.There are several rovers, which are indexed using a number:    data Rover is      (Rover (index:Number))There are several gps stations:    data GPSStation is      (GPS Station (index:Number))There is only one supervision station:    data SupervisionStation is      (Supervision station)What we call a `System` is anything which falls in the 3 categories we just described:    data System is        SupervisionStation      | Rover      | GPSStationWe could also have written all of the above in one go, this way:    data System is        (Supervision station)      | (Rover (index:Number))      | (GPS station (index:Number))Each data type described in LIDL is associated with several interactions. Examples of interactions associated with the `System` data type:  - `(Supervision station)`  - `(Rover (3))`  - `(GPS station (2))`### AlertsHere, we define the different categories of alerts, using data types#### Alerts on roversThere are several categories of alerts concerning rovers    data AlertOnRover is        (GPS Loss)      | (Data Loss)      | (Low Battery)      | (Critical Battery)      | ((which:Wheel) is Blocked)The last option `(... is Blocked)` refers to a data type called `Wheel` which describes the different types of wheel that a rover has. The rovers have two wheels:    data Wheel is        (Left wheel)      | (Right wheel)Examples of interactions that are automatically defined by LIDL when the data types above are defined:  - Constructor (Used to create a data flow with a constant value)    - `(GPS Loss)           :AlertOnRover out`    - `((Left wheel) is Blocked)  :AlertOnRover out`  - Matcher (Used in the switch/case interaction, allows some kind of pattern matching/comparison)    - `(GPS Loss)               :{value: AlertOnRover in, didMatch: Boolean out}`    - `(any AlertOnRover)       :{value: AlertOnRover in, didMatch: Boolean out}`    - `((Left wheel) is Blocked):{value: AlertOnRover in, didMatch: Boolean out}`    - `((any Wheel) is Blocked) :{value: AlertOnRover in, didMatch: Boolean out}`  - Mutation (To modify an instance of a type), here they allow to modify instances of alarts...    - `(do not change)                      :{before: AlertOnRover in, after: AlertOnRover out}`    - `(change to GPS Loss)                 :{before: AlertOnRover in, after: AlertOnRover out}`    - `((change to Right wheel) is Blocked) :{before: AlertOnRover in, after: AlertOnRover out}`The automatical definition of these interactions is formally defined, and will be explicited in the appendix of Vincent Lecrubier's Thesis.#### Alerts on GPS StationsThere are 3 kinds of alerts on GPS stations:    data AlertOnGPSStation is        (GPS Loss)      | (Data Loss)      | (Power Loss)Examples of interactions:  - `(GPS Loss)`  - `(Power Loss)`#### Alerts on supervision stationsThere is only 1 kind of alert on the supervision station    data AlertOnSupervisionStation is        (Power Loss)Examples of interactions:  - `(Power Loss)`#### General case alertTo specify an alert in the general case, we need to specify the *alert* and the *system on which the alert happened*. There a three categories of alerts, one for each category of system:    data Alert is        ((alert:AlertOnRover) on (rover:Rover))      | ((alert:AlertOnGPSStation) on (gpsStation:GPSStation))      | ((alert:AlertOnSupervisionStation) on supervision station)Examples of interactions that LIDL automatically associates with this data type:  - `((Low Battery) on (Rover (1)))`  - `((Data Loss) on (GPS Station (2)))`  - `((Power Loss) on supervision station)`#### Alert occurenceAn alert occurence is the product of an *alert* and of a *date*. It is an alert associated with a specific date:    data AlertOccurence is        (Alert (category:Alert) at (date:Date))Examples of interactions:  - `(((Low Battery) on (Rover (1))) at (2016-06-01T06:00:00Z))`#### Alert levelsThere are three alert levels:    data AlertLevel is        (Caution)      | (Warning)      | (Advisory)We can write an interaction that associates each alert with its specific alert level:    interaction (level of (alert:Alert in) is (level:AlertLevel out))   : Behaviour      ( switch  (alert)                                           : (level)        case    ((GPS Loss) on (Rover (1)))                       : (Caution)        case    ((GPS Loss) on (Rover (any Number)))              : (Warning)        case    ((GPS Loss) on (GPS Station (any Number)))        : (Caution)        case    ((Power Loss) on supervision station)             : (Caution)        case    ((Low Battery) on (any Rover))                    : (Advisory)        case    (((any Wheel) is blocked) on (any Rover))         : (Advisory)        case    (any AlertOnGPSStation)                           : (Warning)        case    (any AlertOnSupervisionStation)                   : (Caution)      )Pattern matching using Comparator interactions allows us to be very specific about alert levels. When several cases match, the case which is written higher in the list is selected. For example here, `((GPS Loss) on (Rover (1)))` will be associated with `(Caution)` even though it also matches `((GPS Loss) on (Rover (any Number)))`.Once this behaviour (that associates a level with each alert) is specified, we can use the `... with behaviour ...` interaction in order to *syntactically project* the behaviour along two prefered directions. This can be used later in order to facilitate the expression of certain behaviours. We can define the following interactions:    interaction (level of (alert:Alert in)):AlertLevel out is      (        (x) with behaviour        (level of (alert) is (x))      )    interaction (an alarm with level (level:AlertLevel out)):Alert in is      (        (x) with behaviour        (level of (x) is (level))      )Examples of interactions that can be expressed using the definitions above:  - `(level of ((Low Battery) on (Rover (1))))`         which gives the value      `(Advisory)`  - `(level of ((Power Loss) on supervision station))`  which gives the value     `(Caution)`  - `((an alarm with level (x)) = (my alert))` which means that `(x)` will receive the level of `(my alert)`#### Alert autoclear and autoackThe same way we defined alert levels, we can express which alert have auto ack and auto clear    interaction ((alert:Alert in) has automatic ack (autoAck:Boolean out) and auto clear (autoClr:Boolean out))   : Behaviour      ( switch  (alert)                                     : ((autoAck),(autoClr))        case    ((GPS Loss) on (Rover (any Number)))        : ((true),(true))        case    ((GPS Loss) on (GPS Station (any Number)))  : ((true),(true))        case    ((Power Loss) on supervision station)       : ((true),(false))        case    (any AlertOnGPSStation)                     : ((false),(false))        case    (any AlertOnSupervisionStation)             : ((true),(false))        case    (any AlertOnRover)                          : ((true),(false))      )    interaction ((alert:Alert in) has auto ack):Boolean out is      (        (x) with behaviour        ((alert) has automatic ack (x) and auto clear (y))         )    interaction ((alert:Alert in) has auto clear):Boolean out is      (        (y) with behaviour        ((alert) has automatic ack (x) and auto clear (y))         )Examples of interactions that can be expressed using the definitions above:  - `(((Low Battery) on (Rover (1))) has auto clear)`         which gives the value      `(false)` (Last case of the switch interaction)  - `(((GPS Loss) on (Rover (12))) has auto ack)`         which gives the value      `(true)` (First case of the switch interaction)### Alert signalsAn alert signal is a composite data that contains a message, an alert level, a date, a state, and a procedure. This is an abstraction of what is presented to the user.    data AlertSignal is      ( AlertSignal (message:Text) (level:AlertLevel)        (date:Date) (state:AlertState) (procedure:Procedure) )The alert signal can be in several states which are explicited in various places of the textual specification:    data AlertState is      (active) | (acknowledged) | (cleared)### ProcedureA procedure is associated with each alert signal. A procedure can be in several states, not started, completed, or at a specific state:    data ProcedureState is      (not yet started) | (completed) | (at step (index:Number))There are two kinds of steps in a procedure: imperative steps (example : "Do this"->"Done"), or conditional steps (example: "Is it ok ?"->"Yes/No")    data ProcedureStep is        (imperative  (message:Text))      | (conditional (message:Text))A procedure is a sequence of steps, in a certain state:    data Procedure is       (procedure (steps:[ProcedureStep]) (state:ProcedureState))     | (no procedure)Example of interactions that can be written using the definitions above:  - Construction (represent a dataflow denoting a procedure)    - `(procedure ([         (imperative (“Do this”))         (imperative (“Do that”))         (conditional (“Is that done ?”))        ]) (at step (2)) )`    - `(no procedure)`  - Mutation (modifies a procedure)    - `(procedure (do not change) (at step (increment)))` increments the step at which the procedure is    - `(procedure (change element (2) by (imperative ("Do these"))) (do not change))` changes the second step of a procedure by replacing it with an imperative step whose message is "Do these", but no not change its state.  - Matcher (matches certain procedures)    - `(procedure (any [ProcedureStep]) (at step (any Number)))` matches any procedure which is started and not completed    - `(procedure (any [ProcedureStep]) (completed))` matches any procedure which is completedThe user can perform 3 actions on a step of a procedure    data Action is      (yes) | (no) | (done)## InterfacesHere we read the [specification](#textual-specification) and express the  <span style='color:DarkTurquoise'>Interfaces</span> using LIDL.### Alert signal presentation    interface AlertSignalPresentation is      {             signal       :  AlertSignal out,        ack          :  Activation in        clr          :  Activation in        launchproc   :  Activation in        cancelproc   :  Activation in      }    interface AlertSignalPresentationList is       AlertSignalPresentation[5]    interface AlertSignalPresentationList is       {    1: AlertSignalPresentation,             2: AlertSignalPresentation,             3: AlertSignalPresentation,             4: AlertSignalPresentation,             5: AlertSignalPresentation       }    interface SignalPresentationAutreMethode is       {     signal :  [AlertSignal] out,             ack    :  [Activation] in       }### Procedure presentation    interface ProcedureStepPresentation is      {         message    : Text out,         procAction : Action in      }Interpretation 1 (Bonne):    interface ProcedurePresentation is      {        currentStep   : ProcedureStepPresentation,        steps         : ProcedureStepPresentation[MAX_STEP]      }Interpretation 2, prends la specification vraiment au pied de la lettre:    interface ProcedurePresentation is      {        stepminus2   : ProcedureStepPresentation,        stepminus1   : ProcedureStepPresentation,        currentStep  : ProcedureStepPresentation,        stepplus1    : ProcedureStepPresentation,        stepplus2    : ProcedureStepPresentation      }### User interface    interface User is      {         alertSignals                         : AlertSignalPresentationList         currentProcedure                     : ProcedurePresentation         indicationOfOtherPendingAlertSignals : Boolean out         numberOfOtherPendingAlertSignals     : Number out         setTransmissible                     : Number in      }## InteractionsThe [specification](#textual-specification) expresses several <span style='color:Green'>Interactions</span>. Here we describe them using LIDL.**TO BE DONE**    interaction      (present alert signals ):AlertSignalPresentationList    is      ()